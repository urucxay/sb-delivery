package ru.skillbranch.sbdelivery.repositoryimport kotlinx.coroutines.flow.Flowimport kotlinx.coroutines.flow.flowimport ru.skillbranch.sbdelivery.db.dao.DishDaoimport ru.skillbranch.sbdelivery.db.dao.FavoriteInfoDaoimport ru.skillbranch.sbdelivery.db.dao.ReviewDaoimport ru.skillbranch.sbdelivery.db.entitiy.DishItemimport ru.skillbranch.sbdelivery.network.DeliveryServiceimport ru.skillbranch.sbdelivery.pref.PrefManagerimport timber.log.Timberclass DishRepository(    private val service: DeliveryService,    private val dishDao: DishDao,    private val reviewDao: ReviewDao,    private val prefManager: PrefManager,    private val favoriteInfoDao: FavoriteInfoDao) {    suspend fun getReviews(        dishId: String,        onSuccess: () -> Unit,        onError: (String) -> Unit    ) = flow {        try {            val reviews = service.fetchReviews(dishId)            emit(reviews)            onSuccess()            Timber.d("Loading successful -> $reviews")        } catch (t: Throwable) {            Timber.d("Network Error -> $t")            onError("Something went wrong...")        }    }    fun getDishById(id: String) = dishDao.getDishById(id)    fun getDishesByRating(rating: Float = 4.8F, limit: Int = 10): Flow<List<DishItem>> =        dishDao.getDishesByRating(rating, limit)    fun getDishesWithMaxLikeCount(limit: Int = 10): Flow<List<DishItem>> =        dishDao.getDishesWithMaxLikeCount(limit)    suspend fun getRecommendDishes(): Flow<List<DishItem>> {        val dishesIds = service.fetchRecommendDishes()        Timber.d("dishes Ids -> $dishesIds")        return dishDao.getDishesByIds(dishesIds)    }    suspend fun toggleFavorite(dishId: String) {        favoriteInfoDao.toggleFavoriteOrInsert(dishId)    }    fun addToCart(dishId: String, count: Int) {        //TODO    }}